## 手些集合框架专题
##### ArrayList 删除原理分析
使用arraycopy往前移动数据,将最后一个变为空
##### java反射机制缺点
java反射机制,不能够获取泛型类型,可以通过字节码技术去获取
##### vector 底层实现原理
Vector 是线程安全的,但是性能比ArrayList要低，Vector 每次扩容为原来的2倍，而ArrayList每次扩容为原来的1.5倍
##### Vector和ArrayList区别
1. Vector是线程安全的，源码中有很多synchronized可以看出，而ArrayList不是。导致Vector效率无法和ArrayList相比    
2. ArrayList和Vector 都采用线性连需存储空间，当存储空间不足的时候，ArrayList默认增加原来的50%,增加后是扩容前的1.5倍(当初始容量为1时,扩容后容量是2),Vector默认增加原来的一倍,增加后是扩容前的2倍        
3. Vector可以设置capacityIncrement,而ArrayList不可以,从字面理解是capacity容量,Increment增加,容量增长的参数.  
##### 单向链表原理
1、为什么需要有Fist：目的是为了查询,从哪里开始(first)到哪里结束(下标结束)   
2、为什么要有last: 添加元素开始   
3、添加原理:在last节点后关联    
4、查询原理:默认从first开始next，从开始节点查询到需要的节点
##### 序列化的作用
序列化的原本意图是希望对一个Java对象作一下“变换”,变成字节序列,这样一来方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失,另外变换成字节序列也更便于网络运输和传播,所以概念上很好理解:序列化:把Java对象转换为字节序列。反序列化:把字节序列恢复为原先的Java对象。
##### transient关键字特点
(1)、一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法被访问    
(2)、transient关键字只能修饰变量,而不能修饰方法和类。注意,本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量,则该类需要实现Serializable接口。    
(3)、一个静态变量不管是否被transient修饰,均不能被序列化(如果反序列化后类中static变量还有值,则值为当前JVM中对应static变量的值)。序列化保存的是对象状态，静态变量保存的是类状态，因此序列化并不保存静态变量。    
##### 看源码时先看构造函数的目的？
目的是确定下是否在构造函数内，进行了初始化操作
##### 如果在链表中存放一个节点，那么first和last分别指向谁？(LinkedList原理)
1、如果只有一个节点node1：first和last都指向node1    
2、如果有两个节点node1和node2：first指向node1,last指向node2    
3、如果有三个节点node1、node2、node3：first指向node1,last指向node2        
为什么要有first节点,目的是为了查询,从哪里开始(first),到哪里结束(下标结束)      
为什么要有last节点,目的是为了标识添加元素开始。 
##### LinkedList底层如何查询的？
如果查询第一个元素，那么执行next为0次,如果查询第二个元素,那么执行next为1次，如果查询第三个元素,那么执行next为2次  
查询原理:就是从头开始往下next,直到查找到需要的节点，下标为几,就next几次 
##### 集合框架使用的技术分析
1、ArrayList集合原理:数组+扩容技术 默认初始化大小为10 线程不安全 特殊：初始容量为1时,下次扩容的大小为2(size+1),以后再次扩容为上次大小的1.5倍,优点查询块(可根据下标直接查),增删慢(需要对数组进行移动元素+覆盖)                 
2、LinkedList集合原理:双向链表 线程不安全 默认添加是在最后一个节点追加,也可根据下标位置进行添加,增删效率比较高,查询需要从头节点查询到目标节点一个一个查，效率比较低        
3、Vector集合原理:数组+扩容技术 默认初始化大小为10 线程不安全 效率不高 jdk1.8每次扩容为原来的2倍    
4、HashMap 底层Jdk1.7采用数组+链表,Jdk1.8采用数组+红黑树(官方说数组+红黑树方式效率是数组+链表效率提高15%); HashMap扩容技术采用:负载因子0.75,HashCode冲突(碰撞)  
##### 数据结构分类
1、数组:连续,有下标位置 优点:查询效率高   
2、链表:单向链表特征:上一个节点(node)保存下一个节点(node) 双向链表特征:下一个节点保存上一个节点和下一个节点next、prev   
3、红黑数:   
4、二叉树：       
##### AQS如何手写锁？
##### ArrayList和LinkedList区别(基本API)？
面试答案：首先LinkedList底层删除或者新增的时候,不会移动数据元素,只会维护内部节点的关系;       
ArrayList删除的时候,将当前元素后面的元素往前移动,这时候会用到数据扩容技术,这种方式效率非常低。
##### LinkedList查询慢的原因,ArrayList查询快的原因?
答案:是因为链表没有下标,需要一个一个遍历查询(从first开始查询);ArrayList可以直接使用下标进行查询,很少有索引
##### HashMap 1.7数组+链表(单链表:只保存下一个节点next),HashMap底层为什么不采用双链表？
答案:HashMap使用不到上一个节点    
数据存储步骤：   
1、先定义数组(数组类型=Node链表)        
2、链表存放那些数据呢？-- hashCode相同，类型为Entry(包含key、value、next)   
3、底层Node<Entry>,hashMap使用取模算法
##### (Jdk1.7)Hash碰撞怎么解决?
答案:链地址法(HashMap采用方式)以链表方式存储,hash相同,entry的key值相同,直接覆盖,如果key值不同直接添加新entry    
1、开放地址法：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止       
    注意：对于利用开放地址法处理冲突所产生的哈希表中删除一个元素时需要谨慎，不能直接地删除，因为这样将会截断其他具有相同哈希地址的元素的查找地址，所以，通常采用设定一个特殊的标志以示该元素已被删除。      
2、再哈希法: 当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止     
3、建立一个公共溢出区:假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录,经过这个方法基本可以解决掉hash算法冲突的问题     
##### HashMap为什么要扩容?
答案:因为链表越长,查询效率越低,节点越多会影响查询效率,链表查询低,最好使用降低hash碰撞问题(减少index冲突问题),如果直接采用hash取模获取到index(没有hash冲突问题查询速度比较快)     
在Jdk 1.7和Jdk 1.8中，HashMap初始化这个容量的时机不同。jdk1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。而在Jdk 1.7中，要等到第一次put操作时才进行这一操作。
##### 扩容数组之后,有什么影响?
hashCode 相同,但是扩容数组之后长度发生变化。需要重新取模计算index
##### 为什么负载因子设置为0.75?
提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小（0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的,限制链表长度,避免查询效率过低）
##### 为什么HashMap初始容量设置为16?
答：HashMap的默认长度为16,是为了降低hash碰撞的几率。


