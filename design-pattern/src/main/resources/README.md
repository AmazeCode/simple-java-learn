##### 什么是反射机制？
正在运行,动态获取类的信息（java源代码--.class字节码）,反射创建对象也会走无参构造函数    
使用反射机制获取类的属性、方法、实例化对象，学习Spring、Hibernate、手些ORM    
##### 反射的应用场景
1、jdbc连接`Class.forName("com.mysql.jdbc.Driver")`  、spring的IOC底层使用的是反射机制+DOM4j    
2、框架Hibernate、mybatis 使用反射机制   
##### 设计模式
学好编码，设计模式 高级开发、架构师是必须要会使用的，23中设计模式，设计模式的用途是方便维护、扩展性、减少冗余代码，降低耦合度，增强可用性,提高可读性。
做项目的时候，了解需求，不要立刻去写代码，拿到需求之后，第一步应该去思考怎么去重构代码。怎么分类、怎么封装，例如：配置文件根据不同的环境需要进行改变，
如果上线后发现配置文件配置错了，传统的方式是把服务停止掉，修改配置文件然后再重启，这样非常不好，一定要使用分布式的配置中心（特点：动态获取配置文件信息,使用zookeeper动态搭建分布式的配置中心）
##### 设计模式分为三大类
1、创建型模式：工厂方法模式、抽象工厂模式、单例模式、原型模式;仅需了解的模式：建造者模式        
2、结构型模式:适配器模式、装饰器模式、代理模式、外观模式;仅需了解的模式：桥接模式、组合模式、享元模式      
3、行为型模式:策略模式、模板方法模式、观察者模式;仅需了解的模式：迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
##### 什么是单例设计模式？
单例模式概念：保证在一个jvm中,只能存在一个实例，保证对象的唯一性。（应用场景：servlet、spring默认单例、struts2、springMVC、连接池、线程池、枚举、常量）    
单例的优缺点：优点：节约内存、重复理用、方便管理；缺点:线程安全问题    
##### 单例的创建方式(总共7种)
1、懒汉式(线程不安全)：类初始化时，会立即加载该对象，线程天生安全，调用效率高;
2、懒汉式(线程安全)    
3、双重检测锁方式(本质也是懒汉式)：（因为JVM重排序的原因，可能会初始化多次，不推荐使用,使用volatile可以避免重排序的问题）， 
4、饿汉式：类初始化时，不会初始化该对象，真是需要使用的时候才会创建该对象，具备懒加载功能;   
5、静态内部类方式：结合懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的;    
6、枚举单例：使用枚举实现单例模式 优点：实现简单、调用效率高、枚举本身就是单例、由jvm从根本上提供保障！避免通过反射和序列化的漏洞，缺点：没有延迟加载
7、容器实现单例模式:这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。  
##### 实际中单例模式的选取方式？
1、不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举好于饿汉式。     
2、如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。
##### 工厂模式
注意:简单工厂不属于23种设计模式,大部分时候使用简单工厂和工厂方法实现即可,写框架的时候才需要用抽象工厂   
工厂模式概念:是用工厂方法代替new操作的一种模式。利用工厂模式可以降低程序的耦合性,为后期修改维护提供很大便利。降选择实现类、创建对象统一管理和控制,从而将调用者跟我们的实现类解耦。
工厂和容器的区别:容器是存放,工厂是生产  
##### 简单工厂、工厂方法、和抽象工厂区别
简单工厂：用来生产同一等级结构中的任意产品。(不支持扩展增加产品)     
工厂方法: 用来生产同一结构中的固定产品(支持扩展增加产品)     
抽象工厂:用来生产不同产品族的全部产品。(不支持扩展增加产品；支持增加产品族)     
抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体的工厂，由具体的工厂生产具体的产品。   
##### 代理设计模式
代理设计模式：通过代理控制对象的访问，可以详细访问某个对象的方法，在这个方法调用之前处理或者调用后处理。即（AOP微实现），AOP核心技术面向切面编程。    
代理模式应用场景: SpringAop、事物原理、日志打印、权限控制、远程调用、安全代理可以隐蔽真实角色。   
##### 代理分类
1、静态代理（静态定义代理类，需要有代理对象）    
2、动态代理(动态定义代理类)  
3、JDK自带动态代理(底层使用的是反射技术)    
4、Cglib、javaassit（字节码操作库）   
##### 什么是动态代理？
1、代理对象，不需要实现接口
2、代理对象的生成是理用JDK的API，动态的在内存中构建代理对象（需要我们指定创建代理对象/目标对象的实现的接口的类型）     
3、动态代理也叫做：JDK代理、接口代理。    
##### CHLIB动态代理
原理：利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。不要求委托类必须要实现接口   
##### JDK动态代理(反射技术)
原理：是根据类加载和接口创建代理类
##### CGLIB动态代理和JDK动态代理区别
java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过
修改子字节码生成子类来处理。  
Spring中：   
1、如果目标对象实现了接口，默认情况下会采用JDK动态代理实现AOP   
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP     
3、如果目标对象没有实现了接口，必须采用CGLIB，spring会自动在JDK动态代理和CGLIB之间切换。   
JDK动态代理只能对实现了接口的类生成代理，而不能针对类。   
CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。    
因为是继承，所以该类或方法最好不要声明为final，final可以阻止继承和多态  
##### 建造者模式
应用场景：1、买东西的时候的组合套餐；2、Java中的StringBuilder,底层使用的是数组(每个数组下标单个数组，String底层使用的是char拼接而成的)    
使用场景:    
1、需要生成的对象具有复杂的内部结构    
2、需要生成的对象内部属于本身相互依赖  
与工厂模式的区别是:建造者模式更加关注与零件装配的顺序。    
##### 模板方法模式
模板方法模式:定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。(重复代码全部在父类里面,不同业务,抽取给子类去实现。抽取过程--抽象方法)          
模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。
因此，模板方法的核心在于定义一个“骨架”。  
##### 什么时候使用模板方法？
实现一操作时,整体步骤是固定的,但是呢,就是其中一小部分容易变,这个时候可以使用模板方法,将容易变的部分抽象出来,供子类实现。   
各个框架中,都有模板方法的影子：数据库访问的封装、Junit单元测试、servlet中关于doGet/doPost方法的调用、Hibernate中模板程序、spring中JDBCTemplate、HibernateTemplate等等       
##### 适配器
适配器分类：类适配器、对象适配器、接口适配器方式    
类适配器方式采用继承方式，对象适配方式采用构造函数传递   
例子：   
1、OutputStreamWriter将输出字符流变为字节流；   
2、InputStreamReader：将输入的字节流变为字符流     
3、SpringMvc中适配器，主要做请求拦截和分发的;    
4、java类库中把String[]转换成list的时候可以使用适配器,注意到List<T> Arrays.asList(T[])就相当于一个转换器，它可以把数组转换为List。
```java
String[] exist = new String[] {"Good", "morning", "Bob", "and", "Alice"};
Set<String> set = new HashSet<>(Arrays.asList(exist));
```
5、假设我们持有一个InputStream，希望调用readText(Reader)方法，但它的参数类型是Reader而不是InputStream，怎么办？
  当然是使用适配器，把InputStream“变成”Reader  
```java
InputStream input = Files.newInputStream(Paths.get("/path/to/file"));
Reader reader = new InputStreamReader(input, "UTF-8");
readText(reader);
```
6、如果我们把readText(Reader)方法参数从Reader改为FileReader，会有什么问题？这个时候，因为我们需要一个FileReader类型，就必须把InputStream适配为FileReader   
```java
FileReader reader = new InputStreamReader(input, "UTF-8"); // compile error!
```
直接使用InputStreamReader这个Adapter是不行的，因为它只能转换出Reader接口。事实上，要把InputStream转换为FileReader也不是不可能，但需要花费十倍以上的功夫。
这时，面向抽象编程这一原则就体现出了威力：持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。    
##### 外观模式(门面模式)
外观模式：隐藏系统的复杂性,并向客户端提供一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。    
##### 设计模式6大原则
1、开闭原则：对扩展开放、对修改关闭；2、里氏代换原则：父类可以出现的地方子类一定可以出现(重写);3、依赖倒转原则：针对接口编程、依赖于抽象而不依赖于具体。
4、迪米特法则：最少知道原则；一个实体应当尽量少的与其他实体之间发生相互作用，使系统功能模块相对独立。5、合成复用原则：尽量使用合成、聚合方式(也就是接口编程),而不是使用继承。    
##### 原型模式
原型模式是一个创建型的模式。被复制的实例就是我们所称的“原型”。(使用原型模式的时候,对象必须要先创建出来)     
##### 原型使用场景
1、类初始化需要消耗非常多资源，通过原型拷贝避免这些消耗    
2、通过new产生的一个对象需要非常繁琐的数据准备后者权限，这时可以使用原型模式。    
3、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型拷贝多个对象供调用者使用，即保护性拷贝   
浅拷贝:只会拷贝基本类型，不会拷贝应用类型,引用类型复制后还是会被共同引用   
深拷贝:会在计算机中开辟新的内存地址。(spring使用的是深拷贝)
##### 策略模式
策略模式的用意是针对一组算法或逻辑，将每个算法或逻辑封装到具有共同接口的独立的类中，从而使得他们之间可以相互替换。






