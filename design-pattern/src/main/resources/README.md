##### 什么是反射机制？
正在运行,动态获取类的信息（java源代码--.class字节码）,反射创建对象也会走无参构造函数    
使用反射机制获取类的属性、方法、实例化对象，学习Spring、Hibernate、手些ORM    
##### 反射的应用场景
1、jdbc连接`Class.forName("com.mysql.jdbc.Driver")`  、spring的IOC底层使用的是反射机制+DOM4j    
2、框架Hibernate、mybatis 使用反射机制   
##### 设计模式
学好编码，设计模式 高级开发、架构师是必须要会使用的，23中设计模式，设计模式的用途是方便维护、扩展性、减少冗余代码，降低耦合度，增强可用性,提高可读性。
做项目的时候，了解需求，不要立刻去写代码，拿到需求之后，第一步应该去思考怎么去重构代码。怎么分类、怎么封装，例如：配置文件根据不同的环境需要进行改变，
如果上线后发现配置文件配置错了，传统的方式是把服务停止掉，修改配置文件然后再重启，这样非常不好，一定要使用分布式的配置中心（特点：动态获取配置文件信息,使用zookeeper动态搭建分布式的配置中心）
##### 设计模式分为三大类
1、创建型模式：工厂方法模式、抽象工厂模式、单例模式、原型模式;仅需了解的模式：建造者模式        
2、结构型模式:适配器模式、装饰器模式、代理模式、外观模式;仅需了解的模式：桥接模式、组合模式、享元模式      
3、行为型模式:策略模式、模板方法模式、观察者模式;仅需了解的模式：迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
##### 什么是单例设计模式？
单例模式概念：保证在一个jvm中,只能存在一个实例，保证对象的唯一性。（应用场景：servlet、spring默认单例、struts2、springMVC、连接池、线程池、枚举、常量）    
单例的优缺点：优点：节约内存、重复理用、方便管理；缺点:线程安全问题    
##### 单例的创建方式(总共7种)
1、懒汉式(线程不安全)：类初始化时，会立即加载该对象，线程天生安全，调用效率高;
2、懒汉式(线程安全)    
3、双重检测锁方式(本质也是懒汉式)：（因为JVM重排序的原因，可能会初始化多次，不推荐使用,使用volatile可以避免重排序的问题）， 
4、饿汉式：类初始化时，不会初始化该对象，真是需要使用的时候才会创建该对象，具备懒加载功能;   
5、静态内部类方式：结合懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的;    
6、枚举单例：使用枚举实现单例模式 优点：实现简单、调用效率高、枚举本身就是单例、由jvm从根本上提供保障！避免通过反射和序列化的漏洞，缺点：没有延迟加载
7、容器实现单例模式:这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。  
##### 实际中单例模式的选取方式？
1、不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举好于饿汉式。     
2、如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。
##### 工厂模式
注意:简单工厂不属于23种设计模式,大部分时候使用简单工厂和工厂方法实现即可,写框架的时候才需要用抽象工厂   
工厂模式概念:是用工厂方法代替new操作的一种模式。利用工厂模式可以降低程序的耦合性,为后期修改维护提供很大便利。降选择实现类、创建对象统一管理和控制,从而将调用者跟我们的实现类解耦。
工厂和容器的区别:容器是存放,工厂是生产  
##### 简单工厂、工厂方法、和抽象工厂区别
简单工厂：用来生产同一等级结构中的任意产品。(不支持扩展增加产品)     
工厂方法: 用来生产同一结构中的固定产品(支持扩展增加产品)     
抽象工厂:用来生产不同产品族的全部产品。(不支持扩展增加产品；支持增加产品族)     
抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体的工厂，由具体的工厂生产具体的产品。   
##### 代理设计模式
代理设计模式：通过代理控制对象的访问，可以详细访问某个对象的方法，在这个方法调用之前处理或者调用后处理。即（AOP微实现），AOP核心技术面向切面编程。    
代理模式应用场景: SpringAop、事物原理、日志打印、权限控制、远程调用、安全代理可以隐蔽真实角色。   
##### 代理分类
1、静态代理（静态定义代理类，需要有代理对象）    
2、动态代理(动态定义代理类)  
3、JDK自带动态代理    
4、Cglib、javaassit（字节码操作库）   
##### 什么是动态代理？
1、代理对象，不需要实现接口
2、代理对象的生成是理用JDK的API，动态的在内存中构建代理对象（需要我们指定创建代理对象/目标对象的实现的接口的类型）     
3、动态代理也叫做：JDK代理、接口代理。    
##### CHLIB动态代理
原理：利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。不要求委托类必须要实现接口   
##### JDK动态代理
原理：是根据类加载和接口创建代理类
##### CGLIB动态代理和JDK动态代理区别
java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过
修改子字节码生成子类来处理。  
Spring中：   
1、如果目标对象实现了接口，默认情况下会采用JDK动态代理实现AOP   
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP     
3、如果目标对象没有实现了接口，必须采用CGLIB，spring会自动在JDK动态代理和CGLIB之间切换。   
JDK动态代理只能对实现了接口的类生成代理，而不能针对类。   
CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。    
因为是继承，所以该类或方法最好不要声明为final，final可以阻止继承和多态  
##### 建造者模式



