##### 多线程
多线程特性:原子性(保证线程能够执行),可见性(我的线程对同一个共享变量可见),有序性
###### 内存结构：jvm内存结构（堆、栈、方法区）
###### java内存模型（JMM）：jmm决定一个线程对共享变量的写入时，能够对另一个线程可见。
抽象概念：    
主内存：存储共享变量    
本地本地内存：共享变量的副本
java内存模型图参考：resources/pic/jmm.png

##### 使用线程同步的时候，应该只需要包裹可能会发生线程安全的问题，即是应该尽量使用同步代码块，少使用同步方法。（原因是方法可被很多地方调用，在方法上加同步，会使得不需要进行同步的地方同步了，会影响程序的运行效率）
使用的锁的方式：   
1、非静态同步方法使用的时this锁   
2、静态同步方法使用的是当前class字节码文件     
###### volatile与synchronized
volatile作用：可以保证可见性，但是不能保证原子性(线程安全问题)、可禁止重排序   
synchronized作用：既可以保证原子性也可以保证可见性    
重排序概念:cpu会对代码实现执行优化，不会对有依赖关系性做重排序，代码执行的顺序可能会发生改变，但是执行结果不会发生任何改变（只会对多线程有影响，对单线程不会有影响）    
什么是数据依赖性关系？  
int a =1；   
int b=2；    
int c=a*b;   
程序执行的时候，可能会先执行 int b=2；然后在执行int a =1；并不会对执行结果产生影响  
as-if-serial语义：不管怎么去做重排序，目的提高并行度，但是不能影响正常的结果。重排序，只在在多线程情况下遇到。    
###### 线程之间如何实现通讯（生产者与消费者）
wait:释放当前锁，但是它会释放锁的资源。    
notify:唤醒当前被锁等待的线程  
对象锁池   
注意：wait和notify一定要在synchronized内进行执行，一定要持有同一把锁。   
###### wait与join的区别？
wait需要使用notify去进行唤醒，而join是不需要进行唤醒的，wait一定要用在同步里面。
##### wait与sleep的区别？
wait会自动释放锁，sleep不会自动释放锁。
##### 为什么要把wait和notify放在Object里？
原因:run方法里面需要用任意对象作为锁，因为Object类是任意对象的父类，所以放在Object里面才能被任意对象拿到。   
##### 并发包
1、核心并发列ConcurrentLinkedQueue(非阻塞式)、BlockingQueue(阻塞式)   
2、阻塞式队列(会等待的叫阻塞式)与非阻塞式队列（不会等待直接执行的叫非阻塞）区别：   
队列:主要遵循先进先出、后进后出的原则。
<1>、入列、出列的区别：   
阻塞式      
入列（存队列）阻塞式队列，入列的时候，如果超出队列总数，这时候会进行等待（阻塞）。   
出列（取队列），如果获取队列为空的情况下，这时候也会进行等待（等待）。  
参考图片：/rsources/pic/阻塞队列和非阻塞队列.png     
阻塞式队列相对于非阻塞式队列更稳定，但是相对于非阻塞效率也更低，现实开发中一般采用阻塞式队列，原因是如果采用非阻塞式队列，生产者不断生产，而消费者发生故障时，数据不停的生产而不能消费会造成数据的丢失，而阻塞式如果消费者出现故障，会进行阻塞，不会造成数据的丢失。

 

  




 

