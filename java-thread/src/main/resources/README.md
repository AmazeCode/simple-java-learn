##### 多线程
多线程特性:原子性(保证线程能够执行),可见性(我的线程对同一个共享变量可见),有序性
###### 内存结构：jvm内存结构（堆、栈、方法区）
###### java内存模型（JMM）：jmm决定一个线程对共享变量的写入时，能够对另一个线程可见。
抽象概念：    
主内存：存储共享变量    
本地本地内存：共享变量的副本
java内存模型图参考：resources/pic/jmm.png

##### 使用线程同步的时候，应该只需要包裹可能会发生线程安全的问题，即是应该尽量使用同步代码块，少使用同步方法。（原因是方法可被很多地方调用，在方法上加同步，会使得不需要进行同步的地方同步了，会影响程序的运行效率）
使用的锁的方式：   
1、非静态同步方法使用的时this锁   
2、静态同步方法使用的是当前class字节码文件     
###### volatile与synchronized
volatile作用：可以保证可见性，但是不能保证原子性(线程安全问题)、可禁止重排序   
synchronized作用：既可以保证原子性也可以保证可见性    
重排序概念:cpu会对代码实现执行优化，不会对有依赖关系性做重排序，代码执行的顺序可能会发生改变，但是执行结果不会发生任何改变（只会对多线程有影响，对单线程不会有影响）    
什么是数据依赖性关系？  
int a =1；   
int b=2；    
int c=a*b;   
程序执行的时候，可能会先执行 int b=2；然后在执行int a =1；并不会对执行结果产生影响  
as-if-serial语义：不管怎么去做重排序，目的提高并行度，但是不能影响正常的结果。重排序，只在在多线程情况下遇到。    
###### 线程之间如何实现通讯（生产者与消费者）
wait:释放当前锁，但是它会释放锁的资源。    
notify:唤醒当前被锁等待的线程  
对象锁池   
注意：wait和notify一定要在synchronized内进行执行，一定要持有同一把锁。   
###### wait与join的区别？
wait需要使用notify去进行唤醒，而join是不需要进行唤醒的，wait一定要用在同步里面。
##### wait与sleep的区别？
wait会自动释放锁，sleep不会自动释放锁。
##### 为什么要把wait和notify放在Object里？
原因:run方法里面需要用任意对象作为锁，因为Object类是任意对象的父类，所以放在Object里面才能被任意对象拿到。   
##### 并发包
1、核心并发列ConcurrentLinkedQueue(非阻塞式)、BlockingQueue(阻塞式)   
2、阻塞式队列(会等待的叫阻塞式)与非阻塞式队列（不会等待直接执行的叫非阻塞）区别：   
队列:主要遵循先进先出、后进后出的原则。
<1>、入列、出列的区别：   
阻塞式      
入列（存队列）阻塞式队列，入列的时候，如果超出队列总数，这时候会进行等待（阻塞）。   
出列（取队列），如果获取队列为空的情况下，这时候也会进行等待（等待）。  
参考图片：/rsources/pic/阻塞队列和非阻塞队列.png     
阻塞式队列相对于非阻塞式队列更稳定，但是相对于非阻塞效率也更低，现实开发中一般采用阻塞式队列，原因是如果采用非阻塞式队列，生产者不断生产，而消费者发生故障时，数据不停的生产而不能消费会造成数据的丢失，而阻塞式如果消费者出现故障，会进行阻塞，不会造成数据的丢失。
阻塞和非阻塞的区别:阻塞是进行加锁，每次只能一个线程进行执行，无阻塞是不会进行等待   
##### 使用线程池的目的
1、降低资源消耗:通过重复利用已创建的线程降低线程创建和销毁造成的消耗。   
2、提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。    
3、提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统稳定性，使用线程池可以进行统一分配，调优和监控。但是要做到合理利用线程池，必须对其实现原理了如指掌。     
##### 创建线程池的四种方式
Executors    
1、newCachedThreadPool---创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。    
2、newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。    
3、newScheduledThreadPool 创建一个定时线程池，支持定时及周期性人物执行。      
4、newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO、优先级）执行。    

##### 线程池原理分析(地城其实就是一个HashSet)
任何用的线程池都是通过ThreadPoolExecutor封装起来的
corePoolSize:核心线程数，表示指实际运行的线程数     
maximumPoolSize:最大线程数，表示最多创建多少个线程   (corePoolSize只能小于等于maximumPoolSize)
如果当前线程池中的线程数目小于corePoolSize,则每来一任务,就会创建一个线程去执行这个任务;    
如果当前线程池中的线程数目>=corePoolSize,则每来一个任务,会尝试将其添加到任务缓存队列中,若添加成功,则该任务会等待空闲线程将其取出执行;若添加失败（一般来说任务缓存队列已满）,则会创建新的线程去执行这个任务;    
如果队列已经满了,则总线程数不大于maximumPoolSize的前提下,则创建新的线程  
如果当前线程池中的数目达到maximumPoolSize,则会采取任务拒绝策略进行处理     
如果线程池中的线程数大于corePoolSize时,如果某线程空闲时间超过keepAliveTime,线程将被终止,直至线程池中的数据不大于corePoolSize;如果允许为核心线程池中的线程设置存活时间,那么核心线程池中的线程空闲时间超过keepAliveTime,线程也会被终止。    
流程图参考：/resources/pic/线程池原理.png    
总结:   
   所谓线程池本质是一个hashSet。多余的任务会放在阻塞队列中。先使用核心线程,核心线程被用完后，存放阻塞队列，只有当阻塞队列满了后，才会触发非核心线程的创建。
   所以非核心线程只是临时过来打杂的。直到空闲了(keepAliveTime超时)，然后自己关闭了,直至线程数小于corePoolSize。
   线程池提供了两个钩子(beforeExecute，afterExecute)给我们，我们继承线程池，在执行任务前后做一些事情。
   线程池原理关键技术：锁(lock,cas)、阻塞队列、hashSet(资源池)      
   
ThreadPoolExecutor提供了四种拒绝策略：    
1、ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。    
2、ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。     
3、ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）     
4、ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，可以通过实现RejectedExecutionHandler接口自定义处理方式。   
##### 为什么线程池要用阻塞队列？
使用阻塞队列的最大作用是能够等待核心线程数去执行任务(核心线程执行的时候肯定是需要时间的,核心线程释放资源后,阻塞队列进行出列,保证资源的复用),假如核心线程一直在执行非阻塞队列那么非阻塞队列不会阻塞立马会进行出列，但是核心线程数是不会执行的，可能会导致线程池挂掉。   
##### 合理配置线程池原则：CPU密集、IO密集
1、CPU密集：该任务(run方法代码)需要大量的运算，而没有阻塞的情况下，CPU全速运行    
##### Future模式
多线程run方法的缺点：没有返回值，如果要获取run方法执行结果，子程序必须要执行完毕才能获取到结果，整个程序是阻塞的。
CallBack的submit方法有点，CallBack创建有返回值，主程序不需要等待之程序执行完毕才能执行，不会造成主程序阻塞。   
应用场景：桌面应用程序（CS）,下载一张图片进行展示，使用子线程进行下载图片，整个应用程序不会阻塞。   

A和B两个线程，如果A需要B的执行结果，那么A线程不需要等待B执行完毕后，才能拿到结果。使用Future模式   
##### 锁
轻量级(Lock)与重量级(synchronized)区别: lock需要自己去上锁和解锁，灵活性更高，二者都具有可重入性(递归)的特性   
什么是重入锁?  
相当于方法里面再嵌套方法，外面方法已经有锁了，里面的方法也有锁，那么外面会把锁传递到里面    
##### 锁的分类
重入锁:Lock(轻量级，需要手动加锁和释放锁)和重量级(synchronized方法执行完后立即释放锁，不需要手动释放锁)     
读写锁：读写分离，高并发的时候写的时候是不能够去读的，否则会造成线程安全问题
悲观锁: 又叫互斥锁（特征：属于重量级锁，会阻塞、会进行等待。）总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁、写锁等，都是在操作之前加锁，java中 synchronized和Lock是悲观锁  
乐观锁：本质上是没有锁的，效率比较高、无阻塞、无等待、失败时会进行重试。      
原子类:线程安全、非阻塞式,本质底层没有使用锁。底层实现原理式CAS无锁技术，比较重试       
CAS无锁技术(无锁机制)：即compare and swap，谈CAS无锁技术一定要谈java内存模型JMM（可以使用synchronized和volatile保证可见性，synchronized也可以保证原子性即线程安全）   
CAS原理: 它包含三个参数CAS(V、E、N)，V表示要更新的变量，E表示预期值，N表示更新值。仅当V值等于E值时，才会将V值设置为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做，最后，CAS返回当前V的真实值。  
可参考图片:/resources/pic/CAS.png
CAS缺点：问题：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？  
如果在这段时间曾经被改成B，然后又改回A，那么CAS操作就会误认为它从来没有被修改过。针对这种情况，java并发包种提供了一个带有标记引用原子类AtomicStampeReference，它可以通过控制变量值的版本来保证CAS的正确性。
##### 互斥锁和自旋锁的区别
互斥锁会等待、阻塞，悲观锁：线程会从sleep(加锁)-->running（解锁），过程中有上下文的切换，cpu抢占，信号的发送等开销。    
自旋锁：线程一直在running（加锁-->解锁），死循环检测锁的标志位，机制不复杂。（注意死循环，使用标志位进行退出）     
公平锁和非公平锁区别：通俗讲就是公平锁是先到先得，按顺序进行，非公平锁就是不排队直接拿，失败再说。（都是基于所内部维护的一个双向链表）   
分布式锁：zookeeper（优先使用）和redis    
##### 并发编程框架-Disruptor(实现原理图参考resources/pic/Disruptor实现原理.png)
Disruptor:底层使用的是环绕数组以及CAS无锁机制实现，相当于简化版的JMS，性能比BlockingQueue高很多   
Disruptor优点：高性能队列，无锁机制，底层CAS，基于事件驱动源
BlockingQueue阻塞对列底层使用锁。生产者、队列容器、消费者


 




 

  




 

