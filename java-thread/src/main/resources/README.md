##### 多线程
多线程特性:原子性(保证线程能够执行),可见性(我的线程对同一个共享变量可见),有序性
###### 内存结构：jvm内存结构（堆、栈、方法区）
###### java内存模型（JMM）：jmm决定一个线程对共享变量的写入时，能够对另一个线程可见。
抽象概念：    
主内存：存储共享变量    
本地本地内存：共享变量的副本
java内存模型图参考：resources/pic/jmm.png

##### 使用线程同步的时候，应该只需要包裹可能会发生线程安全的问题，即是应该尽量使用同步代码块，少使用同步方法。（原因是方法可被很多地方调用，在方法上加同步，会使得不需要进行同步的地方同步了，会影响程序的运行效率）
使用的锁的方式：   
1、非静态同步方法使用的时this锁   
2、静态同步方法使用的是当前class字节码文件     
###### volatile与synchronized
volatile作用：可以保证可见性，但是不能保证原子性(线程安全问题)、可禁止重排序   
synchronized作用：既可以保证原子性也可以保证可见性    
重排序概念:cpu会对代码实现执行优化，不会对有依赖关系性做重排序，代码执行的顺序可能会发生改变，但是执行结果不会发生任何改变（只会对多线程有影响，对单线程不会有影响）    
什么是数据依赖性关系？  
int a =1；   
int b=2；    
int c=a*b;   
程序执行的时候，可能会先执行 int b=2；然后在执行int a =1；并不会对执行结果产生影响  
as-if-serial语义：不管怎么去做重排序，目的提高并行度，但是不能影响正常的结果。重排序，只在在多线程情况下遇到。    
###### 线程之间如何实现通讯（生产者与消费者）
wait:释放当前锁，但是它会释放锁的资源。    
notify:唤醒当前被锁等待的线程  
对象锁池   
注意：wait和notify一定要在synchronized内进行执行，一定要持有同一把锁。   
###### wait与join的区别？
wait需要使用notify去进行唤醒，而join是不需要进行唤醒的，wait一定要用在同步里面。
##### wait与sleep的区别？
wait会自动释放锁，sleep不会自动释放锁。
##### 为什么要把wait和notify放在Object里？
原因:run方法里面需要用任意对象作为锁，因为Object类是任意对象的父类，所以放在Object里面才能被任意对象拿到。   
##### 并发包
1、核心并发列ConcurrentLinkedQueue(非阻塞式)、BlockingQueue(阻塞式)   
2、阻塞式队列(会等待的叫阻塞式)与非阻塞式队列（不会等待直接执行的叫非阻塞）区别：   
队列:主要遵循先进先出、后进后出的原则。
<1>、入列、出列的区别：   
阻塞式      
入列（存队列）阻塞式队列，入列的时候，如果超出队列总数，这时候会进行等待（阻塞）。   
出列（取队列），如果获取队列为空的情况下，这时候也会进行等待（等待）。  
参考图片：/rsources/pic/阻塞队列和非阻塞队列.png     
阻塞式队列相对于非阻塞式队列更稳定，但是相对于非阻塞效率也更低，现实开发中一般采用阻塞式队列，原因是如果采用非阻塞式队列，生产者不断生产，而消费者发生故障时，数据不停的生产而不能消费会造成数据的丢失，而阻塞式如果消费者出现故障，会进行阻塞，不会造成数据的丢失。
##### 使用线程池的目的
1、降低资源消耗:通过重复利用已创建的线程降低线程创建和销毁造成的消耗。   
2、提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。    
3、提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统稳定性，使用线程池可以进行统一分配，调优和监控。但是要做到合理利用线程池，必须对其实现原理了如指掌。     
##### 创建线程池的四种方式
Executors    
1、newCachedThreadPool---创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。    
2、newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。    
3、newScheduledThreadPool 创建一个定时线程池，支持定时及周期性人物执行。      
4、newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO、LIFO、优先级）执行。    

##### 线程池原理分析(地城其实就是一个HashSet)
任何用的线程池都是通过ThreadPoolExecutor封装起来的
corePoolSize:核心线程数，表示指实际运行的线程数     
maximumPoolSize:最大线程数，表示最多创建多少个线程   (corePoolSize只能小于等于maximumPoolSize)
如果当前线程池中的线程数目小于corePoolSize,则每来一任务,就会创建一个线程去执行这个任务;    
如果当前线程池中的线程数目>=corePoolSize,则每来一个任务,会尝试将其添加到任务缓存队列中,若添加成功,则该任务会等待空闲线程将其取出执行;若添加失败（一般来说任务缓存队列已满）,则会创建新的线程去执行这个任务;    
如果队列已经满了,则总线程数不大于maximumPoolSize的前提下,则创建新的线程  
如果当前线程池中的数目达到maximumPoolSize,则会采取任务拒绝策略进行处理     
如果线程池中的线程数大于corePoolSize时,如果某线程空闲时间超过keepAliveTime,线程将被终止,直至线程池中的数据不大于corePoolSize;如果允许为核心线程池中的线程设置存活时间,那么核心线程池中的线程空闲时间超过keepAliveTime,线程也会被终止。    
流程图参考：/resources/pic/线程池原理.png    
总结:   
   所谓线程池本质是一个hashSet。多余的任务会放在阻塞队列中。先使用核心线程,核心线程被用完后，存放阻塞队列，只有当阻塞队列满了后，才会触发非核心线程的创建。
   所以非核心线程只是临时过来打杂的。直到空闲了(keepAliveTime超时)，然后自己关闭了,直至线程数小于corePoolSize。
   线程池提供了两个钩子(beforeExecute，afterExecute)给我们，我们继承线程池，在执行任务前后做一些事情。
   线程池原理关键技术：锁(lock,cas)、阻塞队列、hashSet(资源池)      
   
ThreadPoolExecutor提供了四种拒绝策略：    
1、ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。    
2、ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。     
3、ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）     
4、ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，可以通过实现RejectedExecutionHandler接口自定义处理方式。   
##### 为什么线程池要用阻塞队列？
使用阻塞队列的最大作用是能够等待核心线程数去执行任务(核心线程执行的时候肯定是需要时间的,核心线程释放资源后,阻塞队列进行出列,保证资源的复用),假如核心线程一直在执行非阻塞队列那么非阻塞队列不会阻塞立马会进行出列，但是核心线程数是不会执行的，可能会导致线程池挂掉。   
##### 合理配置线程池原则：CPU密集、IO密集
1、CPU密集：该任务(run方法代码)需要大量的运算，而没有阻塞的情况下，CPU全速运行

 




 

  




 

