##### 什么是垃圾回收机制？jvm不定时的回收不可达的对象。(自动)
垃圾收集系统是java核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无需手工清理   
##### 什么是不可达对象？
对象没有被继续引用、没有存活、没有被继续使用
##### 引用计数法(内存回收算法--已淘汰)
引用计数法会产生循环依赖问题(两个对象，把A赋给B，再把赋给A，然后同时把null赋给A、B，这个时候形成循环依赖，垃圾回收机制不知道怎么回收)   
默认年龄0   
每个对象有一个年龄，如果小于后者等于15岁，存放在新生代里面，如果大于15岁就存放在老年代。   
GC线程不定时进行回收时，如果对象被引用的话，年龄会加1，如果没有被继续引用年龄会减去1.   
如果年龄为0岁的话，会被垃圾回收机制认为是不可达对象，会被清理掉。    
##### GCRoots(根搜索) 
判断是否可达：需要和根节点有依赖关系。   
如果没有和我的GC Roots有任何引用的情况下，这时候GC认为就是不可达对象。必须要和我的GC Roots有任何引用的情况下，这时候GC认为就是可达对象。    
(1)、虚拟机栈(栈帧中的局部变量区，也叫做局部变量表)中引用的对象         
(2)、方法区中的静态属性引用的对象         
(3)、方法区中常量引用的对象            
(4)、本地方法栈中JNI(Native方法)引用的对象        
参考图：根搜索算法(GC roots).png    
根搜索算法的基本思路就是通过一系列名为“GC Roots”的对象最为起始点，从这些节点开始向下搜索，搜索所走过的路径，如果当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的    
GC Roots实际就是对象的引用    
##### 标记清除算法
标记清除算法可以解决循环依赖问题   
##### 标记压缩算法
任意顺序：即不考虑原先对象的排列顺序，也不考虑，对象之间的引用关系，即随意移动对象。    
线性顺序：考虑对象的引用关系，例如a对象引用b对象，则尽可能将a和b移动到一块     
滑动顺序：按照对象原来在堆中的顺序滑动到堆的一端。   
##### 分代算法
根据对象的存活周期的不同将内存划分成几块，新生代和老年代，这样就可以根据各个年代的特点采用最合适点的思路来理解这个算法。     
新生代对象朝生夕死，对象数量多，只要重点扫描这个区域，那么就可以大大提高垃圾收集的效率。
##### 复制算法
参考图:复制算法.png
##### JVM参数配置
-XX:+PrintGC 每次触发GC的时候打印相关日志       
-XX:+UserSerialGC  串行回收       
-XX:+PrintGCDetails 更详细的GC日志         
-Xms          堆初始值      
-Xmx          堆最大可用值      
-Xmn          新生代堆最大可用值     
-XX:+SurvivorRatio 用来设置新生代中eden空间和from/to空间比例       
-XX:NewRatio       用于配置新生代与老年代的占比(一般配置为:1:2)    
总结：在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。    


