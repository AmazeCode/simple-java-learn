##### 什么是垃圾回收机制？jvm不定时的回收不可达的对象。(自动)
垃圾收集系统是java核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无需手工清理   
##### 什么是不可达对象？
对象没有被继续引用、没有存活、没有被继续使用
##### 引用计数法(内存回收算法--已淘汰)
引用计数法会产生循环依赖问题(两个对象，把A赋给B，再把赋给A，然后同时把null赋给A、B，这个时候形成循环依赖，垃圾回收机制不知道怎么回收)   
默认年龄0   
每个对象有一个年龄，如果小于后者等于15岁，存放在新生代里面，如果大于15岁就存放在老年代。   
GC线程不定时进行回收时，如果对象被引用的话，年龄会加1，如果没有被继续引用年龄会减去1.   
如果年龄为0岁的话，会被垃圾回收机制认为是不可达对象，会被清理掉。    
##### GCRoots(根搜索) 
判断是否可达：需要和根节点有依赖关系。   
如果没有和我的GC Roots有任何引用的情况下，这时候GC认为就是不可达对象。必须要和我的GC Roots有任何引用的情况下，这时候GC认为就是可达对象。    
(1)、虚拟机栈(栈帧中的局部变量区，也叫做局部变量表)中引用的对象         
(2)、方法区中的静态属性引用的对象         
(3)、方法区中常量引用的对象            
(4)、本地方法栈中JNI(Native方法)引用的对象        
参考图：根搜索算法(GC roots).png    
根搜索算法的基本思路就是通过一系列名为“GC Roots”的对象最为起始点，从这些节点开始向下搜索，搜索所走过的路径，如果当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的    
GC Roots实际就是对象的引用    
##### 标记清除算法(清除老年代)
标记清除算法可以解决循环依赖问题   
##### 标记压缩算法(清除老年代)
其算法可以看作三步：    
标记垃圾对象      
清除垃圾对象     
内存碎片整理      
任意顺序：即不考虑原先对象的排列顺序，也不考虑，对象之间的引用关系，即随意移动对象。    
线性顺序：考虑对象的引用关系，例如a对象引用b对象，则尽可能将a和b移动到一块     
滑动顺序：按照对象原来在堆中的顺序滑动到堆的一端。 
##### 复制算法(清除新生代)
参考图:复制算法.png
##### 三种算法的比较(复制、标记压缩、标记清除)
 效率： 复制 > 标记整理 > 标记清除  (此处的效率只是简单的对比时间复杂度，实际情况不一定如此)     
 内存利用率： 标记整理 > 标记清除 > 复制     
 内存整齐度： 复制 = 标记整理 > 标记清除  
##### 分代算法
根据对象的存活周期的不同将内存划分成几块，新生代和老年代，这样就可以根据各个年代的特点采用最合适点的思路来理解这个算法。     
新生代对象朝生夕死，对象数量多，只要重点扫描这个区域，那么就可以大大提高垃圾收集的效率。    
 一般是将Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。     
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用“复制算法”，只需要付出少量存活对象的复制成本就可以完成收集。     
在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。     
本质上分代算法就是对标记压缩算法或标记清除算法、复制算法的整合   
##### 内存溢出和内存泄漏区别
1、内存溢出：在分配的java内存无法满足编写的程序、超出最大堆内存空间时，会发生这种情况，比如用到的方法栈过深，大对象过多等
2、内存泄漏：由于代码缺陷导致对象不断创建而垃圾回收无法及时回收对象，或者根本不回收，比如创建线程再不用后不关闭，频繁创建对象而不销毁等，长时间运行下来，再大的内存都会OutOfMemoryError
3、重点说一下两者区别：内存溢出代码本身没有原则问题，最多算是代码品质不高，想要消除报错只能增加java分配的内存或者优化代码、而内存泄漏则是由于代码存在缺陷，如果不修改代码问题，即使分配再大的内存也会最终报错
##### 并行与并发的区别
并行是同时进行(需要物理设备支持,比如单核cpu是没办法进行并行的)       
并发是一个处理器同时处理多个任务    
注意：并行是指多个处理器或者是多核的处理器同时处理多个不同的任务,并发是逻辑上的同时发生,而并不是物理上的同时发生;举例说明：并发是一个人同时吃三个馒头,并行是三个人同时吃三个馒头     
##### JVM参数配置
-XX:+PrintGC 每次触发GC的时候打印相关日志       
-XX:+UserSerialGC  串行回收       
-XX:+PrintGCDetails 更详细的GC日志         
-Xms          堆初始值      
-Xmx          堆最大可用值      
-Xmn          新生代堆最大可用值     
-XX:+SurvivorRatio 用来设置新生代中eden空间和from/to空间比例       
-XX:NewRatio       用于配置新生代与老年代的占比(一般配置为:1:2)    
总结：在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。    
##### HotSpot(JVM)的收集器(垃圾回收算法的具体实现)
1、Serial收集器(通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器)：它是最基本、发展历史最悠久的收集器，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明他只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。参考图：Serial收集器.png;    
2、Serial Old收集器：它是Serial收集器的老年代版，它同样是一个单线程收集器，使用“标记--整理”算法。这个收集器的意义在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要有两大用途：一种是在jdk1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后预案，在并发收集发生Concurrent Mode Failure时使用。       
3、ParNew收集器(-XX:+UseParNewGC)：ParNew收集器其实就是Serial收集器的多线程版本。新生代并行、老年代串行：新生代复制算法、老年代标记-压缩算法   
参数控制：-XX:+UserParNewGC ParNew收集器;-XX:ParallelGCThreads 限制线程数量    
4、Parallel Scavenge收集器(-XX:+UseParallelGC)：是一个新生代收集器，他也是使用复制算法的收集器，又是并行的多线程收集器。看上去和ParNew都一样，但他的特点是他的关注点与其他收集器不同，CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。     
5、Parallel Old 收集器：是Parallel Scavenge收集器的老年代版，使用多线程与“标记--整理”算法。这个收集器在jdk1.6中才开始提供的，直到Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加 Parallel Old收集器。      
特征(4和5要一块使用)：
```java
1、是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。
2、参数控制： -XX:+UseParallelOldGC 
3、只能和Parallel Scavenge配合使用，这个组合常用于注重吞吐量以及CPU资源敏感的场合
```
6、CMS收集器（Concurrent Mark Sweep）：是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。     
   CMS收集器是基于“标记--清除”算法实现的， 他的运作过程相对于前几种收集器来说更复杂一些，整个过程分为4个步骤：      
   
    a、初始标记（CMS inital mark）：需要“stop the world”，但只标记一下GC Roots能直接关联的对象，速度很快。
    b、并发标记（CMS concurrent mark）：是GC Roots Tracing的过程，花费时间长
    c、重新标记（CMS remark）：是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    d、并发清除（CMS concurrent sweep）：是并发清除无用对象。
    优点：并发收集、低停顿。      
 CMS收集器的运作步骤如下图：CMS收集器.png     
 缺点：
 ```java
1、CMS收集器对CPU资源非常敏感。对于并发实现的收集器而言，虽然可以利用多核优势提高垃圾收集的效率，但是由于收集器在运行过程中会占用一部分的线程，这些线程会占用CPU资源，所以会影响到应用系统的运行，会导致系统总的吞吐量降低。CMS默认开始的回收线程数是(cpu数量 + 3) / 4，所以，当机器的CPU数量为4个以上的时候，垃圾回收线程将占用不少于%25的CPU资源，并且随着CPU数量的增加，垃圾回收线程占用的CPU资源会减少。但是，当CPU资源少于4个的时候，垃圾回收线程占用的CPU资源的比例会增大，会影响到系统的运行，假设有2个CPU的情况下，垃圾回收线程将会占据超过50%的CPU资源。所以，在选用CMS收集器的时候，需要考虑，当前的应用系统，是否对CPU资源敏感。
2、垃圾收集的过程中，无法处理浮动垃圾，所以可能会出现Concurrent Mode Failure问题而导致触发一次Full GC。浮动垃圾：是由于CMS收集器的并发清理阶段，清理线程是和用户线程一起运行，如果在清理过程中，用户线程产生了垃圾对象，由于过了标记阶段，所以这些垃圾对象就成为了浮动垃圾，CMS无法在当前垃圾收集过程中集中处理这些垃圾对象。由于这个原因，CMS收集器不能像其他收集器那样等到完全填满了老年代以后才进行垃圾收集，需要预留一部分空间来保证当出现浮动垃圾的时候可以有空间存放这些垃圾对象。在JDK 1.5中，默认当老年代使用了68%的时候会激活垃圾收集，这是一个保守的设置，如果在应用中老年代增长不是很快，可以通过参数 -XX:CMSInitiatingOccupancyFraction 控制触发的百分比，以便降低内存回收次数来提供性能。在JDK 1.6中，CMS收集器的激活阀值变成了92%。如果在CMS运行期间没有足够的内存来存放浮动垃圾，那么就会导致Concurrent Mode Failure失败，这个时候，虚拟机将启动后备预案，临时启动Serial Old收集器来对老年代重新进行垃圾收集，这样会导致垃圾收集的时间边长，特别是当老年代内存很大的时候。所以对参数-XX:CMSInitiatingOccupancyFraction的设置，过高，会导致发生Concurrent Mode Failure，过低，则浪费内存空间。
3、使用的"标记-清除"算法会出现很多内存碎片。过多的内存碎片会影响大对象的分配，会导致即使老年代内存还有很多空闲，但是由于过多的内存碎片，不得不提前触发垃圾Full GC。为了解决这个问题，CMS收集器提供了一个"-XX:+UseCMSCompactAtFullCollection"参数（默认是开启的），用于CMS收集器在必要的时候对内存碎片进行压缩整理。由于内存碎片整理过程不是并发的，所以会导致停顿时间变长。虚拟机还提供了一个-XX:CMSFullGCsBeforeCompaction"参数，来控制进行过多少次不压缩的Full GC以后，进行一次带压缩的Full GC，默认值是0，表示每次在进行Full GC前都进行碎片整理。
```
参数：
```java
-XX:+UseConcMarkSweepGC：使用CMS收集器
-XX:+UseCMSCompactAtFullCollection： Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长。 
-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理。
-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量） 。
```
 7、G1收集器（Garbage-First）：是当今收集器技术发展的最前沿的成果之一，G1是一款面向服务器端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点：
 
       a、并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
       b、分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能够独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
       c、空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记--整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前出发下一次GC。
       d、可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时java（RTSJ）的垃圾收集器的特性了。
       使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，它将整个个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代与老年代的概念，但新生代与老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。
       如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为一下几个步骤：
       a、初始标记（Initial Marking）
       b、并发标记（Concurrent Marking）
       c、最终标记（Final Marking）
       d、筛选回收（Live Data Counting and Evacuation）
 G1收集器运行示意图如下：G1收集器.png 
参数:
```java
-XX:+UseG1GC 使用G1回收器。
-XX:MaxGCPauseMillis  设置最大垃圾收集停顿时间。
-XX:GCPauseIntervalMillis  设置停顿间隔时间。
```    
 如果你现在（jdk1.8）采用的收集器没有出现问题，那就没有任何理由现在去选择G1，如果你的应用追求低停顿，那G1现在已经可以作为一个可尝试的选择，如果你的应用最求吞吐量，那G1并不会为你带来什么特别的好处    
 ##### 理解GC日志 
通过以下两段典型的GC日志进行分析：    
```java
33.125：[GC [DefNew：3324K-＞152K（3712K），0.0025925secs] 3324K-＞152K（11904K），0.0031680 secs]
100.667：[FullGC [Tenured：0K-＞210K（10240K），0.0149142secs] 4603K-＞210K（19456K），[Perm：2999K-＞2999K（21248K）]，0.0150007 secs] <br>[Times：user=0.01 sys=0.00，real=0.02 secs]
```
(1)最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。    
(2)GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc（）方法所触发的收集，那么在这里将显示“[Full GC（System）”。
[Full GC 283.736：[ParNew：261599K-＞261599K（261952K），0.0000288 secs]     
(3)接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。GC发生区域日志与GC收集器对照列表如下：    
```java
GC日志区域名	                        对应GC收集器名      
[DefNew （Default New Generation）	Serial收集器         
[ParNew （Parallel New Generation）	ParNew收集器           
[PSYoungGen	Parallel                Scavenge收集器           
[ParOldGen	Parallel                Old收集器 
```
(4)后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。 
而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。        
(5)再往后,“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒.
有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间(Wall Clock Time).
CPU时间与墙钟时间的区别是,墙钟时间包括各种非运算的等待耗时,例如等待磁盘I/O、等待线程阻塞、而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间,所以读者看到user或sys时间超过real时间是完全正常的
##### JVM调优原则
调优基本原则：   
(1)、减少垃圾回收次数
(2)、堆的初始值一定要和堆的最大值设置成一致(因为垃圾回收次数和堆的最大内存大小无关,和堆的初始内存大小有关)
1、串行垃圾回收(单线程,适用于堆内存较小的时候,适合个人电脑,单线程：垃圾回收发生的时候，其它线程都暂停)
```java
-Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+UseSerialGC -XX:PermSize=32M
```
结论:堆的初始内存一定要和堆的最大内存保持一致;堆的初始值和最大的内存一致,并且初始值越大吞吐量就会越高
(垃圾回收机制次数和堆最大内存的大小无关的,只是和堆的初始内存有关，堆的初始内存会影响吞吐量)
串行回收器配置堆的初始值和堆最大值一致的情况下(512M),垃圾回收次数是0次，最大吞吐量是1400左右
2、并行垃圾回收(-XX:+UsePerNewGC:新生代并行、老年代串行,吞吐量优先,一般公司服务器使用,吞吐量优先、适合于堆内存较大、需要多核CPU)
```java
-Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+UseParNewGC -XX:PermSize=32M
```
并行回收器配置堆的初始值和最大值一致的情况下(512M),测试的垃圾回收次数是0次,最大的吞吐量是1400左右
3、CMS垃圾回收(-XX:+UseConcMarkSweepGC 响应时间优先)
```java
-Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+UseConcMarkSweepGC -XX:PermSize=32M
```
CMS回收器配置堆的初始值和最大值一致的情况下(512M),测试的垃圾回收次数是0次,最大的吞吐量是1400左右


             


