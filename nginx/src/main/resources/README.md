##### 外网映射工具
微信开发、第三方支付的时候。微信事件通知、第三方支付回调通知，如果想在本地开发的话，根本就是无法测试。    
使用第三方外网映射工具，将本地服务映射到外网。主流的工具(natapp ngrok:完全免费)     
外网映射工具：natapp(可免费注册) 基于ngrok实现: 让外网更够访问本地      
插件工具包含网络穿透uTools,项目比较大可以使用付费的Natapp        
##### Nginx的特点(俄罗斯人开发,并发服务器)
1、nginx是一款轻量级的方向代理服务器     
2、nginx可以做服务器,比tomcat资源耗能更低,支持更多的并发连接,更高的效率     
##### Nginx的应用场景(解决方案和应用场景是不一样的)
- 核心功能              
1、Http服务器(使用Nginx做静态服务器、图片服务器)         
2、虚拟主机配置(将一台服务器,拆分多个网站进行部署)        
3、反向代理 使用反向代理隐藏真实ip访问地址    
4、负载均衡(集群):减少单台服务器压力故障转移(重试机制-不建议使用会产生幂等问题、健康检查(tcp、http心跳检测))     
5、安全配置     
- 非核心       
6、使用Nginx搭建API接口网关(网关的目的是对请求的权限安全去进行控制),解决网站跨域        
7、使用Nginx实现网站动静分离      
8、使用Nginx实现防止DDOS(安全控制)--[DDOS频繁访问网站,占用网站宽带,流量攻击]         
9、使用Nginx配置缓存(Http)  
windows版本nginx与linux版本nginx本质上配置没有很大区别
##### Nginx windows 版本启动问题
双击启动nginx.exe文件,一闪而过时,去查看下logs文件夹里面的error.log如果没有错误说明启动成功,也可以通过控制管理器查看nginx进程是否存在    
nginx 默认 启动监听的端口号 80      
Nginx 启动产生端口号80,内部是http服务器   
windows版本启动方式,cmd进入nginx所在目录然后输入:          
1、启动：start nginx 这种方式可以避免杀进程的情况出现      
2、关闭: nginx -s stop
##### Nginx实现虚拟主机配置(原理)
一、基于域名的虚拟主机配置       
假设bbs.amazecode.com和www.amazecode.com最终都在同一台服务器上运行,端口号都是80,这时就可以使用nginx基于域名区分项目(通过文件夹实现)         
配置步骤：(原理图可参考：Nginx配置虚拟主机(基于域名区分项目).png)           
1、配置host文件
```text
127.0.0.1 www.amazecode.com
127.0.0.1 bbs.amazecode.com
```
2、配置nginx配置文件
具体配置参考：nginx-配置虚拟主机(即根据域名跳转目录).conf  
启动nginx后,测试方式直接访问域名
```text
www.amazecode.com     -- 访问的是 www目录
bbs.amazecode.com     -- 访问的是 bbs目录
```   
二、基于端口号的虚拟主机配置
假设域名相同，监听的端口号不一样,比如监听8080,8081,访问时通过域名添加端口号访问          
具体配置参考: nginx-配置虚拟主机(即根据端口号跳转目录).conf     
启动nginx后,测试方式直接访问域名:端口号
```text
www.amazecode.com:8080     -- 访问的是 www目录
bbs.amazecode.com:8081     -- 访问的是 bbs目录
```   
##### 反向代理
1、基于Nginx实现的反向代理(原理参考:Nginx反向代理图.png)        
2、什么是反向代理
```java
nginx拦截所有的请求,内部实现转发到真实服务器地址中
```  
3、反向代理作用   
```java
提高安全性,反向代理主要是隐藏真实ip
抓包工具能不能抓取到nginx代理的节点信息？答案:抓取不到nginx转发的请求比较安全(可以使用Fiddle抓包工具测试)
```
###### 反向代理-根据域名区分服务器的反向代理配置
演示需要配置host
```java
127.0.0.1 www.amazecode.com
127.0.0.1 bbs.amazecode.com
```
本地启动两个项目,端口号分别为8080,8081,分别访问连接都是根路径/,修改好nginx反向代理配置的配置文件后,启动nginx,
通过访问域名进行测试    
```text
www.amazecode.com   -- proxy_pass http://127.0.0.1:8080
bbs.amazecode.com   -- proxy_pass http://127.0.0.1:8081
```    
具体配置可参考:nginx-反向代理(根据域名,隐藏真实ip).conf
###### 反向代理-同域名根据项目名称-location规则配置
```java
127.0.0.1 www.amazecode.com
```
根据项目名称区分代理服务器(同一个server,多个location)  
```text
www.amazecode.com/tomcat8080   -- proxy_pass http://127.0.0.1:8080
www.amazecode.com/tomcat8081   -- proxy_pass http://127.0.0.1:8081
```    
具体配置参考:nginx-反向代理(同域名根据项目名称-location配置).conf
页面访问测试
```text
www.amazecode.com/tomcat8080   跳转到  http://127.0.0.1:8080对应的应用
www.amazecode.com/tomcat8081   跳转到  http://127.0.0.1:8081对应的应用
```
原理参考:反向代理-根据项目名称区分.png          
###### 根据域名区分的反向代理在大型互联网项目此种方式配置叫做API设计
网关作用:拦截请求、请求配置、反向代理          
在nginx和网关一起使用的时候,两者的功能区分:        
1、nginx主要做反向代理功能    
2、网关作用权限控制(互联网安全架构设计,黑名单设计、白名单设计)     
原理参考:API网关设计.png
##### 反向代理-location语法(参考:反向代理-location语法.png)
```text
1、以=开头表示精确匹配,如果匹配根目录(/)结尾的请求,后面不能带任何字符串
2、以^~开头表示uri以某个常规字符串开头,不是正则匹配
3、以~开头表示区分大小写的正则匹配
4、~*开头表示不区分大小写的正则匹配
5、/通用匹配,如果没有其他匹配,任何请求都会匹配到
```
##### 负载均衡
1、什么是负载均衡？  
```text
什么是负载均衡:目的是解决高并发,负载均衡拦截到所有请求,再采用负载均衡算法分配到不同真实的服务器上。
负载均衡作用:减轻单台服务器压力
负载均衡算法(共5中):轮询机制、权重、IP绑定(这三种比较常用)
轮询机制:均匀分配访问,轮流访问请求,服务器配置差不多时使用
```
```text
四层负载均衡器(Nginx)：基于传输层,也叫做基于TCP协议实现负载均衡,LVS软负载和F5硬件负载，在nginx1.9之后支持对四层负载均衡（TCP\UDP层）
七层负载均衡器(Nginx): 基于应用层也叫做基于HTTP协议实现负载均衡,即Web服务器实现负载均衡,在nginx1.9之前只支持七层负载均衡
思考问题:nginx什么版本支持四层负载均衡?nginx在1.9版本之前是不支持四层负载均衡,只能支持http,1.9之后开始支持四层负载均衡
```   
```text
四层负载均衡和七层负载均衡的区别?
四层负载均衡器: 主要在传输层实现负载均衡 ### 主要针对TCP协议
七层负载均衡器：主要在应用层实现负载均衡 ### 主要针对HTTP协议
```  
2、负载均衡给我们带来的问题?
```text
服务器集群(分布式中常见问题)
(1)、分布式session一致性问题
    参考:分布式Session管理解决方案.png
(2)、分布式Job幂等性问题(访问结果一致)
    HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。可以采用接口幂等性设计,比如说订单支付接口时,sql进行更新的时候可以通过订单状态以及订单唯一id为更新条件进行区分
(3)、分布式生成全局ID
    [1]、UUID生成全局ID(比较常用)
        优点:UUID 生成方便，本地生成没有网络消耗
        缺点:不易于存储：UUID 太长，16字节128位，通常以36长度的字符串表示，很多场景不适用;信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成MAC地址泄露，暴露使用者的位置;对MySQL索引不利：如果作为数据库主键，在 InnoDB 引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能
    [2]、基于数据库实现
        对与分数据库的场景比如4个库，每个库先分配一个起始ID(1..4)，每个库的ID在之前的ID基础上加4(数据库的个数)
        如下所示：
        DB1: 1，5，9，…
        DB2: 2, 6, 10, …
        DB3: 3, 7, 11, …
        DB4: 4, 8, 12, …
        优点:只依赖于数据库本身，ID号单调递增，无重复
        缺点:无法扩展
    [3]、Redis实现
        原理:Redis实现分布式唯一ID主要是通过提供像 INCR 和 INCRBY 这样的自增原子命令，由于Redis自身的单线程的特点，所以能保证生成的 ID 肯定是唯一有序的。
        缺点:Redis 是单线程生成，存在性能瓶颈，依赖于redis，需要系统引进redis组件，增加了系统的配置复杂性
    [4]、Snowflake,Twitter开源的分布式ID生成算法
        优点:id呈递增趋势,不依赖数据库等第三方系统,以服务的方式部署,稳定性更高,生成ID的性能也是非常高的,而且可以根据自身业务特性分配bit位,非常灵活
        缺点:如果发生时钟回拨,就可能产生重复的ID
    [5]、百度-UidGenerator
            DefaultUidGenerator
            CachedUidGenerator
    [6]、美团-Leaf
            Leaf-segment
            Leaf-snowflake
(4)、分布式锁解决方案
    [1]、数据库实现分布式锁:标记某字段为唯一、相同数据重复插入会报错
    [2]、基于Redis的实现方式(性能高,redis命令支持的比较好,实现起来比较方便)
        实现思想:获取锁的时候,使用setnx加锁,并使用expire命令为锁添加一个超时时间,超过该时间则自动释放锁,锁的value值为一个随机生成的UUID,通过此在释放锁的时候进行判断。
        获取锁的时候还设置一个获取的超时时间,若超过这个时间则放弃获取锁。释放锁的时候,若是该锁,则执行delete进行锁释放配置Redisson
    [3]、Zookeeper实现
    ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：
        1)、创建一个目录mylock;
        2)、线程A想获取锁就在mylock目录下创建临时顺序节点;
        3)、获取mylock目录下所有的子节点,然后获取比自己小的兄弟节点,如果不存在,则说明当前线程顺序号最小,获得锁；
        4)、线程B获取所有节点,判断自己不是最小节点,设置监听比自己次小的节点;
        5)、线程A处理完,删除自己的节点,线程B监听到变更事件,判断自己是不是最小的节点,如果是则获得锁;
    使用方式
      这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。
    优点
      具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。
    缺点   
    　　因为需要频繁的创建和删除节点,性能上不如Redis方式。
(5)、分布式配置中心
    [1]、spring cloud config配置中心(springcloud自带,添加spring-boot-starter-actuator依赖可以对服务进行刷新,省略配置文件变化需要重启服务的操作)
    [2]、使用阿里开发的Nacos,方便集成SpringCloudAlibaba,需要在Controller上添加@RefreshScope注解动态的刷新配置,也许可以通过在启动类上添加,采取扫包方式
(6)、分布式日志收集
```
3、在Nginx中如何配置负载均衡
```text
使用Upstream Server 上游服务器(使用负载均衡器转发到真实业务逻辑访问的服务器)
Upstream Server 可以配置多个上游服务器(配置多个真实业务逻辑访问到的服务器)
```
Nginx 负载均衡内置功能:故障转移、重试机制、心跳检测(不建议使用:重试机制、心跳检测)
```text
重试机制:可能会发生重复问题(注意幂等性)
心跳检测：tcp和http协议
```
3、负载均衡长用算法
```text
(1)、轮询机制
轮流访问、非常均匀,应用场景：服务器的配置都相同的情况下
(2)、权重机制  
使用weight配置比例等分 比如1:3 ,权重越高,访问的次数就会越多  应用场景:服务器配置不相同（服务器配置决定权重比例关系）
(3)、IP绑定(ip_hash)
通过nginx获取ip地址hash运算固定分配到某个服务器上。Ip绑定可以解决什么问题:可以解决session共享问题
(4)、fair(第三方)
fair算法可以根据页面大小和加载时间长短智能地进行负载均衡,也就是根据后端服务器的响应时间,来分配请求。Nginx本身不支持fair,如果要使用,需要安装upstream fair模块
(5)、url hash绑定(第三方)
按访问的URL的哈希结果来分配请求,使每个URL定向到一台后端服务器,可以进一步提高后端缓存服务器的效率。Nginx本身不支持url hash,如果要使用,需要安装nginx的hash包
```
4、nginx故障转移
```text
nginx在反向代理转发到真实服务器(上游服务器),如果真实服务器出现宕机,延迟的情况下,直接轮询下一个节点
```
##### Rewrite使用
1、判断IP地址来源
```text
## 如果访问的ip地址为192.168.5.165，则返回403 多个写或者(||)
if($remote_addr = 192.168.5.165){
    return 403;
}
```
2、限制浏览器类型访问
```text
# 不允许谷歌浏览器访问， 如果是谷歌浏览器返回500
if($http_user_agent ~ Chrome){
    return 500;
}
```
注意判断条件最好要写到server里面，或者写到location里面
##### Nginx动态负载均衡
Nginx 动态负载均衡实现方案
```text
1、Consul+Consul-template
每次发现配置更改需要reload nginx,重启nginx(不太好)
2、Consul+OpenResty
实现无需reload动态负载均衡
3、Nginx+Consul+UpSync (nginx版本要使用1.9.10版本)
nginx-upsync-module：新浪开发的基于Nginx实现动态配置的三方模块，能拉取Consul的后端server列表,并动态更新Nginx的路由信息
具体搭建过程可参考博客(自己写的):https://blog.csdn.net/qq_21875331/article/details/113605598
实现无需reload动态负载均衡
Raft算法用在Consul中做集群
原理参考:Nginx+Consul+UpSync实现动态均衡原理.png
安装配置流程：参考Nginx+consul+upsync动态负载均衡环境搭建.png
注意:如果分布式配置中心里面配置了Jdbc数据库连接,配置修改后还是需要进行重启服务的(要么配置成懒加载的形式或者实时加载)
```     


